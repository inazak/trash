# km

krivine machine implementation in golang

## Krivine Machine で何が出来るか

ある種のスタックと遷移ルールを使って、ラムダ計算における簡約を行う。
call by name, weak head normal form であり、関数適用する際に、
引数は置換前に簡約されないし、ラムダ抽象の中身も簡約されない。


## Krivine Machine の遷移ルール

Krivine Machine を構成するのは三つの値で、その動作には四つの遷移ルールがある。

三つの値は、評価する対象のラムダ式を持つ `Code` と、未評価の式と環境の組である
Closureを保持するデータスタック `Stack` と、それから変数の値の組を持ったスタックの
環境 `Environment` からなる。ラムダ式を持つ `Code` には変数が含まれるが、
ここでは（0から始まる） de Bruijn index で表現される単なる整数値を持っているだけである。

```
Krivine Machine = Code | Stack | Env
Code = Lambda | Application | Variable(int) 
```

ここから先、`Stack` と `Env` については、スタックの操作を伴うときは、
`Top :: Rest` と書く。またクロージャについては `{Expr, Env}` と書く。
ラムダ抽象のシンボルとして `^` と書く。

四つの遷移ルールは次の通り。なお開始時は `Stack` と `Env` は空となる。
終了の判定も同じで、`Stack` と `Env` が空かどうか、となる。

```
    | Before                              | => | After                             |
    | Code     | Stack    | Env           | => | Code     | Stack       | Env      |
    --------------------------------------------------------------------------------
1.  | (M N)    | S        | E             | => | M        | {N,E} :: S  | E        |
    --------------------------------------------------------------------------------
2.  | ^M       | C :: S   | E             | => | M        | S           | C :: E   |
    --------------------------------------------------------------------------------
3.  | i + 1    | S        | C :: E        | => | i        | S           | E        |
    --------------------------------------------------------------------------------
4.  | 0        | S        | {M,E1} :: E2  | => | M        | S           | E1       |
    --------------------------------------------------------------------------------
```

ルール1では、関数適用を分解して、引数と環境をClosureにしてStackにプッシュ。
Codeには左辺だけが残る。

ルール2では、ラムダ抽象の本体を簡約するために、スタックの最上位のClosureを
Envにプッシュ。

ルール3,4では、変数の値に紐づくClosureが見つかるまで、値を減らす。
変数は de Bruijn index で表現されているので、変数 `0` の値は
Envの一番上にあるし、`1` の値はその下にある。


## 具体的な動作

簡単な例から。Closureでスタックを表現するときは `[Item]` を使っている。

全く面白くないが、下記の例では4ステップでStackとEnvが空になり停止する。
元のラムダ式通りの簡約結果になる。

```
expression:      (^x.x ^y.y)
de bruijn index: (^.0 ^.0)

    | Code                     | Stack                    | Env                   |
    -------------------------------------------------------------------------------
1.  | (^.0 ^.0)                |                          |                       |
2.  | ^.0                      | {^.0 []}                 |                       |
3.  | 0                        |                          |  {^.0 []}             |
4.  | ^.0                      |                          |                       |
    -------------------------------------------------------------------------------
```

もう少し長い例にする。

```
expression:      ((^x.^y.(y x) ^a.a) ^b.b)
de bruijn index: ((^.^.(0 1) ^.0) ^.0)

    | Code                     | Stack                       | Env                        |
    ---------------------------------------------------------------------------------------
1.  | ((^.^.(0 1) ^.0) ^.0)    |                             |                            |
2.  | (^.^.(0 1) ^.0)          | {^.0, []}                   |                            |
3.  | ^.^.(0 1)                | {^.0, []}, {^.0, []}        |                            |
4.  | ^.(0 1)                  | {^.0, []}                   | {^.0, []}                  |
5.  | (0 1)                    |                             | {^.0, []}, {^.0, []}       |
6.  | 0                        | {1, [{^.0, []},{^.0, []}]}  | {^.0, []}, {^.0, []}       |
7.  | ^.0                      | {1, [{^.0, []},{^.0, []}]}  |                            |
8.  | 0                        |                             | {1, [{^.0, []},{^.0, []}]} |
9.  | 1                        |                             | {^.0, []}, {^.0, []}       |
10. | 0                        |                             | {^.0, []}                  |
11. | ^.0                      |                             |                            |
    ---------------------------------------------------------------------------------------
```

ただ、これだとラムダ抽象に適用する引数が多くても少なくても、未定義の動作になる。



